<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Java面试-集合 | 
	 
	架构师
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">架构师</a>

	<ul id="menu">
    
      <li class="menu-item">
        <a href="/about" class="menu-item-link">ABOUT</a>
      </li>
    

    
      <li class="menu-item">
        <a href="/tags" class="menu-item-link">标签</a>
      </li>
    

    
      <li class="menu-item">
        <a href="/categories" class="menu-item-link">分类</a>
      </li>
    

    
      
      
        <li class="menu-item">
          <a href='https://jxch-capital.github.io/' class="menu-item-link" target="_blank">
            jxch-capital-blog
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://jiangxicheng.site/capital/' class="menu-item-link" target="_blank">
            jxch-capital-web
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://jxch.github.io/' class="menu-item-link" target="_blank">
            jxch-blog
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://blog.csdn.net/jxch____' class="menu-item-link" target="_blank">
            CSDN-blog
          </a>
        </li>
      
    
  
    
      <li class="menu-item">
        <a href='https://github.com/jxch' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00.知识图谱
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/13/00.%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/05-06-%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/">
                     
										    05-06.电商系统
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/14/00.%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/05-07.DDD%E8%AE%BE%E8%AE%A1/">
                     
										    05-07.DDD设计
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/14/00.%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/05-08-IM%E7%B3%BB%E7%BB%9F/">
                     
										    05-08.IM系统
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02.并发编程
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/16/02.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-JMM/">
                     
										    01.JMM
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03.性能调优
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										04.RockDB
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/11/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/04.RockDB/01-RockDB/">
                     
										    01.RockDB
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										06.电商系统
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/08/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/01-%E5%8D%95%E4%BD%93VS%E5%BE%AE%E6%9C%8D%E5%8A%A1/">
                     
										    01.单体VS微服务
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/08/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/02-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9E%B6%E6%9E%84/">
                     
										    02.多数据源架构
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/08/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/03-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%8B%86%E5%88%86/">
                     
										    03.微服务架构拆分
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/08/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/04-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/">
                     
										    04.微服务全链路灰度发布
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/09/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/05-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID/">
                     
										    05.分布式唯一ID
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/09/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/06-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%95%B4%E5%90%88OAuth2-0%E6%8E%88%E6%9D%83%E4%B8%AD%E5%BF%83/">
                     
										    06.微服务网关整合OAuth2.0授权中心
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/09/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/07-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
                     
										    07.订单系统设计
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/10/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/08-%E6%94%AF%E4%BB%98%E8%B6%85%E6%97%B6/">
                     
										    08.支付超时
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/10/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/09-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">
                     
										    09.分布式事务
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/10/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/10-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98/">
                     
										    10.高并发缓存
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/10/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/11-%E6%95%B0%E6%8D%AE%E9%AB%98%E5%8F%AF%E7%94%A8/">
                     
										    11.数据高可用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/10/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/12-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/">
                     
										    12.秒杀系统
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/11/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/13-Sentinel%E9%99%90%E6%B5%81/">
                     
										    13.Sentinel限流
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/11/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/14-%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99/">
                     
										    14.高并发读写
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/11/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/15-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/">
                     
										    15.海量数据
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/11/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/16-ES%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/">
                     
										    16.ES数据迁移
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/12/06.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/17-%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8F%90%E5%8D%87/">
                     
										    17.架构师提升
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										07.DDD设计
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/13/07.DDD%E8%AE%BE%E8%AE%A1/01.DDD%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">
                     
										    01.DDD设计思想
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/13/07.DDD%E8%AE%BE%E8%AE%A1/02.DDD%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">
                     
										    02.DDD四层架构设计
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/14/07.DDD%E8%AE%BE%E8%AE%A1/03-DDD%E9%80%9A%E7%94%A8%E5%9E%8B%E9%A2%86%E5%9F%9F/">
                     
										    03.DDD通用型领域
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										08.IM系统
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/07/14/08.IM%E7%B3%BB%E7%BB%9F/01-IM%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/">
                     
										    01.IM系统基础功能
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/14/08.IM%E7%B3%BB%E7%BB%9F/02-IM%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/">
                     
										    02.IM系统高并发架构
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java区块链
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/29/Java%E5%8C%BA%E5%9D%97%E9%93%BE/Java%E5%8C%BA%E5%9D%97%E9%93%BE/">
                     
										    Java区块链
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java编程参考
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/Java%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83/Java%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83-About/">
                     
										    Java编程参考-About
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										日志
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/Java%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83/%E6%97%A5%E5%BF%97/slf4j/">
                     
										    slf4j
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										流库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/Java%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83/%E6%B5%81%E5%BA%93/Optional/">
                     
										    Optional
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java面试
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-JVM/">
                     
										    Java面试-JVM
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/30/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-RabbitMQ/">
                     
										    Java面试-RabbitMQ
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/">
                     
										    Java面试-基础
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                     
										    Java面试-字符串
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/">
                     
										    Java面试-集合
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	Java面试-集合
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>姜希成</span>
	<span>2023-12-29 10:04:42</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
          
              <span>
                  <i class="fa fa-folder" aria-hidden="true">
                  <a href="/categories/JAVA/">JAVA</a>
                  </i>
                
              </span>
          
      
    

    
		    <span>Tags：</span>
        
            
                <span>
                    <i class="fa fa-tag" aria-hidden="true">
                    <a href="/tags/Java面试/">Java面试</a>
                    </i>
                </span>
            
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<p>Java面试-集合：<br>[TOC]</p>
<h1 id="java有哪些集合？"><a href="#java有哪些集合？" class="headerlink" title="java有哪些集合？"></a><code>java</code>有哪些集合？</h1><ul>
<li>实现<code>Collection</code>接口和 <code>Map</code>接口的</li>
<li><code>Collection</code>子接口 -&gt; <code>List</code>接口 和 <code>Set</code> 接口</li>
<li><code>List</code>：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>(线程安全)</li>
<li><code>Set</code>: <code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></li>
<li><code>Map</code>：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>HashTable</code>(线程安全)</li>
</ul>
<h2 id="List与Set、Map区别？"><a href="#List与Set、Map区别？" class="headerlink" title="List与Set、Map区别？"></a><code>List</code>与<code>Set</code>、<code>Map</code>区别？</h2><ul>
<li><code>List</code>和<code>Set</code>是存储单列数据的集合。<code>Map</code>是存储键值对的。</li>
<li><code>List</code> 有序，值允许重复 <ul>
<li><code>ArrayList</code>基于数组实现，<strong>增删慢，查找快</strong>；<ul>
<li>优点：是随机读取效率很高，原因数组是连续（随机访问性强，查找速度快）</li>
<li>缺点：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中要往后移的，且大小固定不易动态扩展</li>
</ul>
</li>
<li><code>LinkedList</code>基于链表实现，链表内存是散列的，<strong>增删快，查找慢</strong>； <ul>
<li>缺点：不能随机查找，每次都是从第一个开始遍历（查询效率低）。</li>
</ul>
</li>
</ul>
</li>
<li><code>Set</code> 无序， 值不允许重复</li>
<li><code>Map</code>中存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的；<ul>
<li><code>TreeMap</code>，能够把它保存的记录根据键排序，默认是<strong>键的升序排序</strong></li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组通过角标进行随机访问的时间复杂度为<code>O(1)</code><ul>
<li>为什么数组能支持随机访问呢？<ul>
<li><strong>数组占用的内存空间是连续的</strong></li>
<li>数组中都为<strong>同一类型的元素</strong>（内存地址与基址之间的偏移字节，每次都偏移相同的字节）</li>
</ul>
</li>
<li>为什么数组增加删除慢呢？（增加同理）<ul>
<li>数组是一个有序列表 ，数组是在连续的位置上面储存对象的应用。当我们删除某一个元素的时候在他后面的元素的索引都会左移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> </p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li>在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续。 任意位置插入元素和删除元素的速度快，时间复杂度是<code>o(1)</code></li>
<li>链表中的元素有两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址。每一个数据都会保存下一个数据的内存地址，通过该地址就可以找到下一个数据</li>
<li>查找数据时间效率低，时间复杂度是<code>o(n)</code>：因为链表的空间是分散的，所以<strong>不具有随机访问性</strong>，如果需要访问某个位置的数据，需要从第一个数开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度是<code>o(n)</code></li>
</ul>
<h2 id="ArrayList-扩容原理"><a href="#ArrayList-扩容原理" class="headerlink" title="ArrayList 扩容原理"></a><code>ArrayList</code> 扩容原理</h2><ol>
<li><code>ArrayList</code>初始长度为0（这里以jdk17为例）</li>
<li>通过<code>add()</code>方法添加单个元素时，会先检查容量，看是否需要扩容。如果容量不足需要扩容则调用<code>grow()</code>扩容方法<ul>
<li>当第一次调用<code>add</code>后，长度变为10 (初始长度为0的话)<ul>
<li>判断如果为空数组，则两者取最大值默认容量10 (<code>DEFAULT_CAPACITY</code>&#x3D;10, <code>minCapacity=size+1</code>&#x3D;1)</li>
<li><code>minCapacity</code>代表最小的新容量</li>
</ul>
</li>
<li><code>newCapacity = oldCapacity + max(minCapacity-oldCapacity, oldCapacity&gt;&gt;1)</code>, 即<strong>至少1.5倍</strong><ul>
<li><code>minGrowth=minCapacity-oldCapacity</code>, 代表最小的扩容范围</li>
</ul>
</li>
<li>如果新数组长度大于<code>Integer.MAX_VALUE - 8</code>，就使用<code>minGrowth</code>或<code>Integer.MAX_VALUE - 8</code><ol>
<li>如果<code>minGrowth</code>的长度溢出了就报错（特殊的JVM接近<code>Integer.MAX_VALUE</code>时即便有足够内存也会报错）</li>
<li>如果<code>minGrowth</code>小于<code>Integer.MAX_VALUE - 8</code>就返回<code>Integer.MAX_VALUE - 8</code></li>
<li>否则使用<code>minGrowth</code>：此时新数组容量大于<code>Integer.MAX_VALUE - 8</code>却没有内存溢出，范围在<code>Integer.MAX_VALUE - 8</code>和<code>Integer.MAX_VALUE</code>之间</li>
</ol>
</li>
</ul>
</li>
<li>通过<code>Arrays.copyOf</code>方法把原数组的内容放到更大容量的数组里面</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制可能取决于某些 JVM （例如 HotSpot）实现特定的特征，例如对象标头大小。所以选择保守的大小。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;</span><br><span class="line">    <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(</span><br><span class="line">            <span class="string">&quot;Required array length &quot;</span> + oldLength + <span class="string">&quot; + &quot;</span> + minGrowth + <span class="string">&quot; is too large&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><code>LinkedList</code></h2><p><code>LinkedList</code>底层的实现基于<strong>双向表</strong>。每个<code>Node</code>实例除了保存节点的真实值(真实数据)外，还保存了这个节点的前一个节点的引用和后一个节点的引用。底层是<code>Node</code>节点 <code>next</code>指向下一个<code>node</code>的地址。<code>Prev</code>指向上一个<code>node</code>。</p>
<h3 id="根据索引查找-node-int-index"><a href="#根据索引查找-node-int-index" class="headerlink" title="根据索引查找 node(int index)"></a>根据索引查找 <code>node(int index)</code></h3><p>所有根据索引的查找操作都是按照双向链表的需要执行的，根据索引从前或从后开始搜索，并且<strong>从最靠近索引的一端开始</strong>。这样做的目的可以提升查找效率。那如何做到这一点呢？在<code>LinkedList</code>内部有一个<code>node(int index)</code>方法，它会<strong>判断从头或者从后开始查找比较快</strong>。</p>
<p>通过比较 <code>index</code> 和容量右移一位（相当于除以2）的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-add-E-e"><a href="#添加-add-E-e" class="headerlink" title="添加 add(E e)"></a>添加 <code>add(E e)</code></h3><p><code>add(E e)</code>方法实际上调用的是<code>linkLast(E e)</code>方法，意思是把元素<strong>加到链表的最后</strong>。</p>
<ol>
<li><code>first</code>和<code>last</code>，分别保存了当前链表<strong>第一个节点和最后一个节点</strong>的引用。</li>
<li>在新增一个节点之前，首先把指向最后一个节点的引用（即变量 <code>last</code>）保存起来（即变量 l）</li>
<li>然后新建一个节点，把<strong>新节点的前驱设为链表最后一个节点</strong>，把<strong>指向最后一个节点的引用（<code>last</code>）指向新建的节点</strong>。</li>
<li>然后把<strong>链表最后一个节点的后继节点设为新建的节点</strong></li>
<li>最后把整个链表的总数加1，完成了新增一个节点的操作。</li>
</ol>
<p>图示：</p>
<ol>
<li><code>a ⇆ b(last)</code></li>
<li><code>a ⇆ b(last, l) ← c</code></li>
<li><code>a ⇆ b(l) ← c(last)</code></li>
<li><code>a ⇆ b(l) ⇆ c(last)</code></li>
<li><code>size++;</code></li>
<li><code>modCount++;</code> 并发控制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList中的transient关键字和序列化"><a href="#ArrayList和LinkedList中的transient关键字和序列化" class="headerlink" title="ArrayList和LinkedList中的transient关键字和序列化"></a><code>ArrayList</code>和<code>LinkedList</code>中的<code>transient</code>关键字和序列化</h2><p><code>transient</code>关键字的作用，简单地说，就是让某些被修饰的成员属性变量<strong>不被序列化</strong>。</p>
<ul>
<li><code>arratlsit</code>中的 <code>elementData</code> 设置为了 <code>transient</code> 。<ul>
<li><code>elementData</code><strong>不总是满的</strong>，每次都序列化，<strong>会浪费时间和空间</strong></li>
<li>重写了 <code>writeObject</code> 保证序列化的时候虽然不序列化全部, 但是<strong>有的元素都序列化</strong>。不是不序列化而是不全部序列化</li>
</ul>
</li>
<li><code>LinkedList</code>中将<code>first</code>和<code>last</code>修饰成<code>transient</code>是为了节省空间和重新连接链表。</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h1><p>HashMap 为什么使用红黑树，而不是其他的树？</p>
<ul>
<li>为什么不使用二叉排序树？原因：二叉排序树在添加元素的时候<strong>极端情况下会出现线性结构</strong>。<ul>
<li>由于二叉排序树左子树所有节点的值均小于根节点的特点，如果我们添加的元素都比根节点小，会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷，导致查询时间增长。</li>
</ul>
</li>
<li>为什么不使用平衡二叉树呢？红黑树<strong>不追求”完全平衡”<strong>。它能</strong>保证在最坏的情况</strong>下，基本动态集合操作时间为<code>O(logn)</code>.是功能、性能、空间开销的<strong>折中结果</strong>。</li>
</ul>
<h2 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a><code>HashMap</code> 的实现原理</h2><p><code>map.put(k,v)</code> 实现原理：</p>
<ol>
<li>首先将<code>k,v</code>封装到<code>Node</code>对象当中（节点）</li>
<li>调用<code>K</code>的<code>hashCode()</code>方法得出<code>hash</code>值，将<code>hash</code>值转换成<strong>数组的下标</strong></li>
<li>下标位置上如果没有任何元素，就把<code>Node</code>添加到这个位置上</li>
<li>下标对应的位置上如果有链表。此时，就会拿着<code>k</code>和链表上每个节点的<code>k</code>进行<code>equal</code><ul>
<li>如果所有的<code>equals</code>方法返回都是<code>false</code>，那么这个新的节点将被添加到<strong>链表的末尾</strong>。</li>
<li>如其中有一个<code>equals</code>返回了<code>true</code>，那么这个节点的<code>value</code>将会被<strong>覆盖</strong>。</li>
</ul>
</li>
</ol>
<p><code>map.get(k)</code>实现原理：</p>
<ol>
<li>调用<code>k</code>的<code>hashCode()</code>方法得出哈希值，并通过哈希算法转换成<strong>数组的下标</strong>。</li>
<li>通过数组下标快速定位到某个位置上<ul>
<li>如果这个位置上**什么都没有，则返回<code>null</code>**。</li>
<li>如果这个位置上有<strong>单向链表</strong>，那么它就会拿着参数<code>K</code>和单向链表上的每一个节点的<code>K</code>进行<code>equals</code><ul>
<li>如果都返回<code>false</code>，则<code>get</code>方法返回<code>null</code>。</li>
<li>如果其中一个节点的<code>K</code>和参数<code>K</code>进行<code>equals</code>返回<code>true</code>，那么<code>get</code>方法返回这个要找的<code>value</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="HashMap-的扩容原理"><a href="#HashMap-的扩容原理" class="headerlink" title="HashMap 的扩容原理"></a><code>HashMap</code> 的扩容原理</h3><p><code>hashmap</code>集合的默认初始化容量为<code>16</code>，默认加载因子为<code>0.75</code>，也就是说这个默认加载因子是当<code>hashMap</code>集合底层数组的容量达到<code>75%</code>时，数组就开始扩容。为了达到<strong>散列均匀</strong>，提高<code>hashmap</code>集合的存取效率,<code>hashmap</code>集合初始化容量是<code>2</code>的倍数。</p>
<p><code>JDK8</code>之后，如果哈希表单向链表中元素超过<code>8</code>个，那么单向链表这种数据结构会变成<strong>红黑树</strong>数据结构。当红黑树上的节点数量小于<code>6</code>个，会重新把红黑树变成<strong>单向链表</strong>数据结构。红黑树的阈值为什么是<code>8</code>？</p>
<ul>
<li>首先和<code>hashcode</code>碰撞次数的泊松分布有关，主要是为了寻找一种<strong>时间和空间的平衡</strong>。在负载因子<code>0.75</code>（<code>HashMap</code>默认）的情况下，<strong>单个<code>hash</code>槽内元素个数为<code>8</code>的概率小于百万分之一</strong>。</li>
<li>红黑树转链表的阈值为<code>6</code>，主要是因为，如果也将该阈值设置于<code>8</code>，那么当<code>hash</code>碰撞在<code>8</code>时，会发生<strong>链表和红黑树的不停相互转换</strong>，白白浪费资源。</li>
</ul>
<p><code>HashMap</code>扩容大小为什么是<code>2</code>的幂? </p>
<ul>
<li>2的幂可以保证数组的长度是一个偶数，这样可以避免一些奇偶性的问题。</li>
<li>2的幂可以让<code>HashMap</code>的散列函数更简单高效，只需要用<code>hash</code>值和数组长度减一做按<strong>位与运算</strong>，就可以得到元素在数组中的位置。这样可以减少乘法和取模的开销，提高性能。</li>
<li>2的幂可以让<code>HashMap</code>的<strong>扩容更方便</strong>，只需要将数组长度乘以2，就可以得到新的容量。这样可以保证<strong>元素在扩容后的位置要么不变，要么在原来的基础上加上数组的旧长度</strong>。这样可以<strong>减少元素的重新散列</strong>，提高效率。</li>
</ul>
<p><code>Hash</code> 计算: </p>
<ul>
<li>使高<code>16</code>位也参与到<code>hash</code>的运算能减少冲突</li>
<li>索引：<code>(n - 1) &amp; hash</code><ul>
<li><code>n</code>永远是<code>2</code>的次幂，所以 <code>n-1</code> 通过 二进制表示，永远都是<strong>尾端以连续<code>1</code>的形式</strong>表示</li>
<li>当<code>(n - 1)</code> 和 <code>hash</code> 做与运算时，会保留<code>hash</code>中 后 <code>x</code> 位的 <code>1</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 索引为 (n - 1) &amp; hash</span></span><br><span class="line">    tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap在jdk1-7和jdk1-8的区别"><a href="#HashMap在jdk1-7和jdk1-8的区别" class="headerlink" title="HashMap在jdk1.7和jdk1.8的区别"></a><code>HashMap</code>在<code>jdk1.7</code>和<code>jdk1.8</code>的区别</h3><ul>
<li>1.7采用数组+单链表，1.8在单链表超过一定长度后改成<strong>红黑树</strong>存储</li>
<li>1.7插入元素到单链表中采用头插入法，1.8采用的是<strong>尾插入法</strong>。<ul>
<li>在<code>jdk1.7</code>中采用头插入法，扩容时会改变链表中元素原本的顺序，以至于<strong>在并发场景下导致链表成环的问题</strong>。而在<code>jdk1.8</code>中采用尾插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</li>
</ul>
</li>
<li>1.7<strong>扩容时</strong>需要重新计算哈希值和索引位置，消耗性能，而且多线程环境下会造成死锁。<strong>1.8并不重新计算哈希值，巧妙地采用<code>hash</code>和扩容后容量减一进行&amp;操作来计算新的索引位置</strong>。<ul>
<li>索引是 <code>(n - 1) &amp; hash</code>, 当数组长度扩大一倍时，相当于在最高位加了一个<code>0</code>，那么原来的<code>hash</code>值和新的数组长度减一做按位与运算，<strong>结果要么和原来一样，要么多了一个旧容量的值</strong>。</li>
<li>比如旧容量：<code>n=0100</code>; 新容量：<code>n=1000</code>；则旧<code>(n - 1) = 0011</code>；新<code>(n - 1) = 0111</code><ul>
<li>如果<code>Key</code>的 <code>hash</code> 是 <code>0011</code>, 则<code>0011 &amp; 0011 == 0011 &amp; 0111</code>, 位置不变</li>
<li>如果<code>Key</code>的 <code>hash</code> 是 <code>1111</code>, 则<code>1111 &amp; 0011 != 1111 &amp; 0111</code><ul>
<li>新位置增加了<code>0100</code>,相当于旧数组的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HashMap多线程有什么问题"><a href="#HashMap多线程有什么问题" class="headerlink" title="HashMap多线程有什么问题"></a><code>HashMap</code>多线程有什么问题</h2><ol>
<li>程序经常占了100%的CPU。CPU利用率过高，查看堆栈，你会发现程序都Hang在了<code>HashMap.get()</code>这个方法上了。那为什么会出现在get方法上呢？<ul>
<li>因为多线程情况下，对同一个<code>HashMap</code>做<code>put</code>操作可能导致两个或以上线程同时做<code>rehash</code>动作，就可能导致循环链表出现，一旦出现线程将无法终止，持续占用CPU，导致CPU使用率居高不下</li>
</ul>
</li>
<li>多线程<code>put</code>的时候可能导致元素丢失<ul>
<li>主要问题出在<code>addEntry</code>方法的<code>new Entry (hash, key, value, e)</code>，如果两个线程都同时取得了<code>e</code>,则他们下一个元素都是<code>e</code>，然后赋值给<code>table</code>元素的时候有一个成功有一个丢失。</li>
</ul>
</li>
</ol>
<p>什么叫<code>rehash</code>？<code>Hash</code>表这个容器当有数据要插入时，都会检查容量有没有超过设定的<code>thredhold</code>，如果超过，需要增大<code>Hash</code>表的尺寸，但是这样一来，整个<code>Hash</code>表里的元素都需要被重算一遍。这叫<code>rehash</code></p>
<p>解决方案:</p>
<ol>
<li><code>Hashtable</code>替换<code>HashMap</code></li>
<li><code>Collections.synchronizedMap</code>将<code>HashMap</code>包装起来</li>
<li><code>ConcurrentHashMap</code>替换<code>HashMap</code></li>
</ol>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h1><p><code>ConcurrentHashMap</code>是<code>HashMap</code>的一个线程安全的、支持高效并发的版本。在默认理想状态下，<code>ConcurrentHashMap</code>可以支持<code>16</code>个线程执行并发写操作及任意数量线程的读操作。</p>
<p>底层数据结构:</p>
<ul>
<li>&lt;jdk1.7&gt; ：使用 <code>Segment</code>数组 + <code>HashEntry</code>数组 + 链表</li>
<li>&lt;jdk1.8&gt; ：使用 <code>Node</code>数组 + 链表 + 红黑树</li>
</ul>
<p>效率:</p>
<ul>
<li>&lt;jdk1.7&gt;：<code>ConcurrentHashMap</code> 使用的<strong>分段锁</strong>，如果一个线程占用一段，别的线程可以操作别的部分</li>
<li>&lt;jdk1.8&gt;：简化结构，<code>put</code>和<code>get</code>不用二次哈希，<strong>一把锁只锁住一个链表或者一棵树</strong>，并发效率更加提升</li>
</ul>
<p>通过什么保证线程安全:</p>
<ul>
<li>&lt;JDK1.7&gt;:分段锁, 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>&lt;jdk1.8&gt;: 使用的是 <code>synchronized</code> 关键字（优化后效率很高）同步代码块和 <code>cas</code>(乐观锁)操作了维护并发。</li>
</ul>
<h2 id="CouncurrentHashMap-lt-jdk1-7-gt"><a href="#CouncurrentHashMap-lt-jdk1-7-gt" class="headerlink" title="CouncurrentHashMap &lt;jdk1.7&gt;"></a><code>CouncurrentHashMap &lt;jdk1.7&gt;</code></h2><p>底层一个<code>Segments</code>数组，存储一个<code>Segments</code>对象，（其实就相当于一段一段的）一个<code>Segments</code>中储存一个<code>Entry</code>数组，存储的每个<code>Entry</code>对象又是一个链表头结点。</p>
<p>图示(相当于HashMap嵌套HashMap，只不过第一层是加锁的，分段锁思想，所以需要两次Hash计算才能确定位置)：</p>
<p><code>|Segments Arr| -&gt; |Segment(Lock) -&gt; Entry List| -&gt; |Entry -&gt; NodeList| -&gt; |KV Node|</code></p>
<ul>
<li> <code>Segment</code>内部类，继承<code>ReentrantLock</code></li>
<li><code>get</code>方法：<ol>
<li>第一次哈希找到对应的<code>Segment</code>段，调用<code>Segment</code>中的<code>get</code>方法</li>
<li>再次哈希找到对应的链表</li>
<li>最后在链表中查找</li>
</ol>
</li>
<li><code>put</code>方法：<ol>
<li>首先确定段的位置</li>
<li>调用<code>Segment</code>中的<code>put</code>方法<ol>
<li>加锁 <code>lock()</code>;</li>
<li>检查当前<code>Segment</code>数组中包含的<code>HashEntry</code>节点的个数，如果超过阈值就重新<code>hash</code>(扩容)<ul>
<li>只是对 <code>Segments</code>对象中的<code>Hashentry</code>数组进行重哈希</li>
</ul>
</li>
<li>然后再次<code>hash</code>确定放的链表。</li>
<li>在对应的链表中查找是否相同节点，如果有直接覆盖，如果没有将其放置链表尾部</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="CouncurrentHashMap-lt-jdk1-8-gt"><a href="#CouncurrentHashMap-lt-jdk1-8-gt" class="headerlink" title="CouncurrentHashMap &lt;jdk1.8&gt;"></a><code>CouncurrentHashMap &lt;jdk1.8&gt;</code></h2><p><code>putVal</code>:</p>
<ol>
<li>如果数组”空”，进行数组初始化</li>
<li>找该 <code>hash</code> 值对应的数组下标，得到第一个节点 <code>f</code><ul>
<li>如果数组该位置为空，用一次 <code>CAS</code> 操作将新<code>new</code>出来的 <code>Node</code>节点放入数组<code>i</code>下标位置</li>
<li>如果不为空。用 <code>synchronized</code> 修饰</li>
</ul>
</li>
</ol>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><code>Collections</code>工具类</h1><p><code>Collections</code>是集合工具类，用来对集合进行操作。<code>Collections</code> 是一个操作 <code>Set</code>、<code>List</code> 和 <code>Map</code> 等集合的工具类。<code>Collections</code> 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：</p>
<ul>
<li><code>Collections.synchronizedXxx</code>: 同步集合</li>
<li><code>emptyXxx</code>: 空不可变</li>
<li><code>singletonXxx</code>: 单元素不可变</li>
<li><code>unmodifiableXxx</code>: 不可变</li>
<li><code>addAll</code>: 将所有指定元素添加到指定 <code>collection</code> 中</li>
<li><code>reverse</code>: 反转指定列表<code>List</code>中元素的顺序。</li>
<li><code>shuffle</code>: 集合元素进行随机排序，类似洗牌</li>
<li><code>replaceAll</code>: 使用新值替换 <code>List</code> 对象的所有旧值</li>
</ul>
<p>如何将集合里的对象进行去重？ 需要重写比较对象的<code>HashCode</code>与<code>equal</code>方法</p>
<ul>
<li><code>Stream</code>流式去重: <code>distinct</code></li>
<li><code>HashSet</code>：通过调用元素内部的<code>hashCode</code>和<code>equals</code>方法实现去重，首先调用<code>hashCode</code>方法，比较两个元素的哈希值，如果哈希值不同，直接认为是两个对象，停止比较。如果哈希值相同，再去调用<code>equals</code>方法，返回<code>true</code>，认为是一个对象。返回<code>false</code>，认为是两个对象。</li>
</ul>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-JVM/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Java面试-JVM
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2023/12/29/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                Java面试-字符串
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start">2023</span>-<span id="footerYear-end"></span>
	<a href="/">姜希成</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>